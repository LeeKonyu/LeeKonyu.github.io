I"<p>最近在学习Ross Harmes/Dustin Diaz写的<a href="http://book.douban.com/subject/3329540/" target="_blank">《JavaScript设计模式》</a>，大概将此书看了两遍，很有收获。此书适合于想深入学习JavaScript的同学，用来增加你的内功。能够帮助你增强对JavaScript面向对象的理解，同时学习各种具体的设计模式，懂得应该在什么场合使用这些设计模式，以及如何实现它们，写出更优雅的代码。这篇文章用于总结我的读书笔记。</p>

<h4 id="富有表现力的javascript">富有表现力的JavaScript</h4>

<p>为什么说JavaScript是富有表现力的呢？</p>

<ul>
  <li>JavaScript的灵活性：它允许你模仿其他语言的编程模式和惯用法，同时也具备自己独特的编程模式和惯用法。这样你可以根据自己的技术背景和喜好选择编写代码的方式。</li>
  <li>弱语言类型：定义变量的时候不需要申明其类型，其类型取决于其包含的数据；同时JavaScript变量可以根据所赋值改变类型。</li>
  <li>函数是一等对象：它们可以存储在变量中，可以作为参数传递给其他函数，可以作为返回值从其他函数传出，还可以在运行时进行构造。同时JavaScript中使用匿名函数来创建闭包，保护变量空间。</li>
  <li>对象的易变性：JavaScript中所有对象都是易变的，可以使用一些在大多数语言中不允许的技术，例如为函数增加属性；同时还具备内省的概念，可以在运行时检查对象的属性和方法；而已在JavaScript中，任何东西都可以在运行时候修改。</li>
  <li>继承：JavaScript使用的是基于对象的（原型式（prototypal））继承，它可以用了模仿类的继承。</li>
  <li>JavaScript中的设计模式：使用原因：1）可维护性，降低模块间的耦合。2）沟通，可以在较高层面上对其进行讨论，而不必涉及过多的细节。3）性能：合适的设计模式可以大幅提高程序的运行速度，并减少传送到客户端的代码量。</li>
</ul>

<h4 id="接口">接口</h4>

<p>接口是面向对象JavaScript程序员工具箱中最有用的工具之一。但是JavaScript中没有内置创建或者实现接口的方法，也没有内置的方法用于判断一个对象是否实现了与另一个对象相同的一套方法。</p>

<p><strong>什么是接口呢？</strong></p>

<p>对于JavaScript初学者很少在自己的js代码中使用接口，那么到底什么是接口呢？接口提供了一种用以说明一个对象应该具有哪些方法的手段，用来表明方法的语义，但是不规定方法是如何实现的。</p>

<p><strong>接口的好处是啥呢？</strong></p>

<ul>
  <li>既定的一批对象具有自我描述性，并能促进代码的重用。接口可以告诉一个程序员一个类实现了哪些方法，从而帮助其使用这个类。</li>
  <li>接口有助于稳定不同类之间的通信方式，事先知道了接口，就能减少在集成两个对象过程中出现的问题。</li>
  <li>使测试和调试变得更加轻松，用于检测类型不匹配，同时还能使代码变得更加稳固。</li>
</ul>

<p>但是接口并非没有缺点，使用接口在一定程度上面强化了类型的作用，降低了语言的灵活性。由于接口带来额外的方法调用开销，对性能造成一定影响。而且JavaScript没有提供对接口的内置支持（JavaScript中没有interface和implements关键字），需要去模仿一些其他语言的接口，导致无法强迫其他程序员遵循你定义的接口，这也是我认为接口在使用中存在的最大问题。</p>

<p><strong>在JavaScript中模仿接口</strong></p>

<p>注释法、属性检查法和鸭式辨形法（把对象的实现方法集作为判断它是不是某个类实例的唯一标准。也就是说如果对象具有与接口定义的方法同名的所有方法，那么就可以认为它实现了这个接口，“像鸭子一样走路并且嘎嘎叫的就是鸭子，<em>外国程序员真会玩</em>”）。没有哪种技术是完美的，但三者的结合使用基本上 可以令人满意。</p>

<p>建议采用注释法和鸭式辨形法这两种方法综合使用，我们用注释申明类支持的接口，从而提高代码的可重用性及其文档的完善性。我们还用辅助类Interface及其类方法Interface.ensureImplements来对对象实现方法进行显示检查。如果对象未能通过检查，这个方法将返回一条错误的消息。</p>

<p>下面是结合使用Interface类与注释的实例。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">//Interface</span>
<span class="kd">var</span> <span class="nx">Composite</span><span class="o">=</span><span class="k">new</span> <span class="nx">Interface</span><span class="p">(</span><span class="dl">'</span><span class="s1">Composite</span><span class="dl">'</span><span class="p">,[</span><span class="dl">'</span><span class="s1">add</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">remove</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">getChild</span><span class="dl">'</span><span class="p">]);</span>
<span class="kd">var</span> <span class="nx">FormItem</span><span class="o">=</span><span class="k">new</span> <span class="nx">Interface</span><span class="p">(</span><span class="dl">'</span><span class="s1">FormItem</span><span class="dl">'</span><span class="p">,[</span><span class="dl">'</span><span class="s1">save</span><span class="dl">'</span><span class="p">]);</span>

<span class="c1">// CompositeForm class</span>
<span class="kd">var</span> <span class="nx">CompositeForm</span><span class="o">=</span><span class="kd">function</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span><span class="nx">method</span><span class="p">,</span><span class="nx">action</span><span class="p">){</span>
<span class="c1">//implements Composite,FormItem</span>
    <span class="p">...</span>
<span class="p">};</span>
<span class="p">...</span>

<span class="kd">function</span> <span class="nx">addForm</span><span class="p">(</span><span class="nx">formInstance</span><span class="p">){</span>
    <span class="nx">Interface</span><span class="p">.</span><span class="nx">ensureImplements</span><span class="p">(</span><span class="nx">formInstance</span><span class="p">,</span><span class="nx">Composite</span><span class="p">,</span><span class="nx">FormItem</span><span class="p">);</span>
    <span class="c1">//如果一个调用的方法没有被执行，函数将会扔出一个错误</span>
    <span class="c1">//中断程序的执行</span>
    <span class="c1">//只有在检查正确通过后，之后的代码才会被执行</span>
<span class="p">}</span></code></pre></figure>

<p>判断在代码总是否使用接口是否划算是最后重要也是最困难的一步，对于小型的、不太费事的项目来说，接口的好处并不明显，只是徒增复杂度而已。你需要自行权衡其利弊。</p>

<p>对于工厂模式、组合模式、装饰者模式、命令模式尤其依赖接口。使用接口使代码耦合度降低，在对代码进行优化和重构时候将获得更大的自由。</p>

<h4 id="封装和信息隐藏">封装和信息隐藏</h4>

<p>为对象创建私用成员是任何面向对象语言中的最基本和有用的特性之一。通过将一个方法或属性声明为私用，可以让对象的实现细节对其他对象保密以降低对象之间的耦合程度，可以保持数据完整性并对其修改方式加以约束。也即封装是面向对象设计的基石。</p>

<p>封装和信息隐藏之间可以看作同一个概念的两种表达。信息隐藏是目的，而封装则是借以达到这个目的的技术，封装可以定义为对象的内部数据表现形式和实现细节进行隐藏。</p>

<p><strong>创建对象的基本模式</strong>
JavaScript中创建对象的基本模式有3中：</p>

<ul>
  <li>门户大开型：按照传统类型创建一个类，用一个函数来做其构造器，所有属性和方法都是公开的，可访问的。以下示例是为每个属性增加了取值器和赋值器方法。</li>
</ul>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript">         <span class="kd">var</span> <span class="nx">Book</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">isbn</span><span class="p">,</span> <span class="nx">title</span><span class="p">,</span> <span class="nx">author</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">setIsbn</span><span class="p">(</span><span class="nx">isbn</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">setTitle</span><span class="p">(</span><span class="nx">title</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">setAuthor</span><span class="p">(</span><span class="nx">author</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">Book</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">checkIsbn</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">isbn</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">...</span>
        <span class="p">};</span>
        <span class="nx">getIsbn</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">isbn</span><span class="p">;</span>
        <span class="p">},</span>
        <span class="na">setIsbn</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">isbn</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">checkIsbn</span><span class="p">(</span><span class="nx">isbn</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">Book:Invalid ISBN</span><span class="dl">'</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">isbn</span> <span class="o">=</span> <span class="nx">isbn</span><span class="p">;</span>
        <span class="p">},</span>
        <span class="na">getTitle</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">title</span><span class="p">;</span>
        <span class="p">},</span>
        <span class="na">setTitle</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">title</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">title</span> <span class="o">=</span> <span class="nx">title</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">No title specified</span><span class="dl">'</span><span class="p">;</span>
        <span class="p">},</span>
        <span class="na">getAuthor</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">author</span><span class="p">;</span>
        <span class="p">},</span>
        <span class="na">setAuthor</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">title</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">author</span> <span class="o">=</span><span class="nx">author</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">No author specified</span><span class="dl">'</span><span class="p">;</span>
        <span class="p">},</span>
        <span class="na">display</span><span class="p">:</span><span class="kd">function</span><span class="p">(){</span>
            <span class="p">...</span>
        <span class="p">}</span>
    <span class="p">};</span>
    </code></pre></figure>

<ul>
  <li>用命名规范区别私用成员：和本质上面此模式和门户大开型对象创建如出一辙，只不过在一些方法和属性的名称的前面加了下划线表示其私用性而已。</li>
</ul>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript">         <span class="kd">var</span> <span class="nx">Book</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">isbn</span><span class="p">,</span> <span class="nx">title</span><span class="p">,</span> <span class="nx">author</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">setIsbn</span><span class="p">(</span><span class="nx">isbn</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">setTitle</span><span class="p">(</span><span class="nx">title</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">setAuthor</span><span class="p">(</span><span class="nx">author</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">Book</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">checkIsbn</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">isbn</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">...</span>
        <span class="p">};</span>
        <span class="nx">getIsbn</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_isbn</span><span class="p">;</span>
        <span class="p">},</span>
        <span class="na">setIsbn</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">isbn</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">checkIsbn</span><span class="p">(</span><span class="nx">isbn</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">Book:Invalid ISBN</span><span class="dl">'</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">isbn</span> <span class="o">=</span> <span class="nx">isbn</span><span class="p">;</span>
        <span class="p">},</span>
        <span class="na">getTitle</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_title</span><span class="p">;</span>
        <span class="p">},</span>
        <span class="na">setTitle</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">title</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">_title</span> <span class="o">=</span> <span class="nx">title</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">No title specified</span><span class="dl">'</span><span class="p">;</span>
        <span class="p">},</span>
        <span class="na">getAuthor</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_author</span><span class="p">;</span>
        <span class="p">},</span>
        <span class="na">setAuthor</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">title</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">_author</span> <span class="o">=</span><span class="nx">author</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">No author specified</span><span class="dl">'</span><span class="p">;</span>
        <span class="p">},</span>
        <span class="na">display</span><span class="p">:</span><span class="kd">function</span><span class="p">(){</span>
            <span class="p">...</span>
        <span class="p">}</span>
    <span class="p">};</span>
    </code></pre></figure>

<p>下划线的这种用法表示一个属性（或方法）仅对对象内部使用，直接访问它或者设置它可能会导致意想不到的后果。但是这只是一种约定，只有在遵循时候才有效果。主要适合于非敏感性的内部方法和属性。</p>

<ul>
  <li>用闭包实现私用成员：使用闭包可以创建只允许特定函数访问的变量，而且这些变量在这些函数中的各次调用关系依然存在。我么使用var来申明这些变量，意味着它们只存在那个构造器中。</li>
</ul>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">Book</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">newIsbn</span><span class="p">,</span> <span class="nx">newTitle</span><span class="p">,</span> <span class="nx">newAuthor</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//implements Publication</span>
    <span class="c1">//Private attributes</span>
    <span class="kd">var</span> <span class="nx">isbn</span><span class="p">,</span> <span class="nx">title</span><span class="p">,</span> <span class="nx">author</span><span class="p">;</span>

    <span class="c1">//Private method</span>
    <span class="kd">function</span> <span class="nx">checkIsbn</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>

    <span class="c1">//privileged methods</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">getIsbn</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">isbn</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setIsbn</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">isbn</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">checkIsbn</span><span class="p">(</span><span class="nx">newIsbn</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">Book:Invalid ISBN</span><span class="dl">'</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">isbn</span> <span class="o">=</span> <span class="nx">newIsbn</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">getTitle</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">title</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setTitle</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">title</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">title</span> <span class="o">=</span> <span class="nx">newTitle</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">No title specified</span><span class="dl">'</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">getAuthor</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">author</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setAuthor</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">title</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">author</span> <span class="o">=</span> <span class="nx">newAuthor</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">No author specified</span><span class="dl">'</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="c1">//Constructor code</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setIsbn</span><span class="p">(</span><span class="nx">newIsbn</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setTitle</span><span class="p">(</span><span class="nx">newTitle</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setAuthor</span><span class="p">(</span><span class="nx">newAuthor</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">//Public,non-privileged methods</span>
<span class="nx">Book</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">display</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre></figure>

<p>需要访问这些变量和函数只需申明在Book中即可，这些方法被称为特权方法(privileged method)，因为它们是公开方法，但是能够访问私用属性和方法。为了在外部访问这些特权函数，它们的前面都被加上了关键字this。</p>

<p><strong>封装的优缺点</strong></p>

<p>封装保护了内部数据的完整性。通过将数据的访问限制为取值器和赋值器这两个方法，可以获得对取值和赋值的完全控制；同时封装可以使重构变得更轻松；通过只公开那些在接口中规定的方法，可以弱化模块间的耦合，这是面向对象设计最重要的原则之一。</p>

<p>但是私用方法很难进行测试，因为它们及其内部变量都是私用的，所以在外部很难访问它们；同时封装意味着不得不与复杂的作用链打交道，而这会使错误调试更加困难；同时在JavaScript中实现封装很困难，没有对封装提供内置的支持，必须依赖一些其他的技术。</p>

<h4 id="继承">继承</h4>

<p>在JavaScript中继承是一个非常复杂的话题，比起其他任何面向对象的语言中继承都复杂得多。在太多事其他面向对象语言中，继承只需要一个关键字即可。但是在JavaScript中要想达到传承共用成员的目的，需要采取一系列措施。继承可以减少重复性的代码，并且尽量弱化对象之间的耦合。</p>

<p><strong>类式继承</strong></p>

<p>首先要做的是创建构造函数。按惯例，其名称就是类名，首字母应该大写。在构造函数中创建实例的属性要使用关键字this。类的方法被添加到其prototype对象中，要创建该类的实例，只需结合关键字new调用这个构造函数即可。然后你可以访问所有的实例属性，也可以调用所有的实例方法。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="cm">/*Class Person */</span>
<span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="o">=</span><span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span><span class="o">=</span><span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">reader</span><span class="o">=</span><span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">'</span><span class="s1">John Smith</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">reader</span><span class="p">.</span><span class="nx">getName</span><span class="p">();</span></code></pre></figure>

<p>创建继承Person的类要复杂一些：</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="cm">/* Class Author */</span>
<span class="kd">function</span> <span class="nx">Author</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span><span class="nx">books</span><span class="p">){</span>
    <span class="c1">//Call the superclass's constructor in the scope of this</span>
    <span class="nx">Person</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="c1">//add an attribute to Author</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">books</span><span class="o">=</span><span class="nx">books</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//set up the prototype chain</span>
<span class="nx">Author</span><span class="p">.</span><span class="nx">prototype</span><span class="o">=</span><span class="k">new</span> <span class="nx">Person</span><span class="p">();</span>
<span class="c1">//set the constructor attribute to Author</span>
<span class="nx">Author</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="kd">constructor</span><span class="o">=</span><span class="nx">Author</span><span class="p">;</span>
<span class="nx">Author</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getBooks</span><span class="o">=</span><span class="kd">function</span><span class="p">(){</span>
    <span class="c1">//add a method to Author</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">books</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>为了让Author继承Person，必须手工将Author的prototype设置为Person的一个实例。最后一个步骤是将prototype的constructor属性重设为Author(定义一个构造函数时，其默认的prototype对象是一个Object类型的实例，其constructor属性会自动设置为该构造函数本身。如果手工将其prototype设置为另一对象，那么新对象自然不会具有原对象的constructor值，所以需要重新设置其constructor值)</p>

<p>为了简化类的申明，可以将派生子类的整个过程包装在一个名为<strong>extend</strong>的函数中，它的作用和其他语言中的extend关键字类似，即基于一个给定的类结构创建一个新的类。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="cm">/* Extend functions.*/</span>
<span class="kd">function</span> <span class="nx">Extend</span><span class="p">(</span><span class="nx">subClass</span><span class="p">,</span><span class="nx">superClass</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">F</span><span class="o">=</span><span class="kd">function</span><span class="p">(){};</span>
    <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span><span class="o">=</span><span class="nx">superClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
    <span class="nx">subClass</span><span class="o">=</span><span class="nx">prototype</span><span class="o">=</span><span class="k">new</span> <span class="nx">F</span><span class="p">();</span>
    <span class="nx">subClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="kd">constructor</span><span class="o">=</span><span class="nx">subClass</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>这个函数所做的事情和先前我们手工做的一样，它设置了prototype，然后将其constructor重新设为恰当的值，作为一项改进，它添加了一个空函数F，并将其创建的一个对象实例插入原型链中，这样做可以避免创建超类的新实例。
使用extend函数后，前面那个Person/Author例子变成了这个样子：</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="cm">/*Class Person */</span>
<span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="o">=</span><span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span><span class="o">=</span><span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span>
<span class="p">}</span>

<span class="cm">/* Class Author */</span>
<span class="kd">function</span> <span class="nx">Author</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span><span class="nx">books</span><span class="p">){</span>
    <span class="nx">Person</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">books</span><span class="o">=</span><span class="nx">books</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">extend</span><span class="p">(</span><span class="nx">Author</span><span class="p">,</span><span class="nx">Person</span><span class="p">);</span>
<span class="nx">Author</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getBooks</span><span class="o">=</span><span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">books</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><strong>原型式继承</strong></p>

<p>使用原型式继承时，并不需要用类的对象来定义对象的结构，只需要直接创建一个对象即可。这个对象随后可以被新的对象重用，这得意于原型链查找的工作机制。下面我们使用原型链继承来重新设计Person和Author：</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="cm">/*Person Prototype Object*/</span>
<span class="kd">var</span> <span class="nx">Person</span><span class="o">=</span><span class="p">{</span>
    <span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">default name</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">getName</span><span class="p">:</span><span class="kd">function</span><span class="p">(){</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">reader</span><span class="o">=</span><span class="nx">clone</span><span class="p">(</span><span class="nx">Person</span><span class="p">);</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">reader</span><span class="p">.</span><span class="nx">getName</span><span class="p">());</span><span class="c1">//default name</span>
<span class="nx">reader</span><span class="p">.</span><span class="nx">name</span><span class="o">=</span><span class="dl">'</span><span class="s1">Tang Wei</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">reader</span><span class="p">.</span><span class="nx">getName</span><span class="p">());</span><span class="c1">//Tang Wei</span>

<span class="cm">/*Author Prototype Object*/</span>
<span class="kd">var</span> <span class="nx">Author</span><span class="o">=</span><span class="nx">clone</span><span class="p">(</span><span class="nx">Person</span><span class="p">);</span>
<span class="nx">Author</span><span class="p">.</span><span class="nx">books</span><span class="o">=</span><span class="p">[];</span><span class="c1">//default value</span>
<span class="nx">Author</span><span class="p">.</span><span class="nx">getBooks</span><span class="o">=</span><span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">books</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>这里并没有使用一个名为Person的构造函数来定义类的结构，Person现在是一个对象字面量。它是所需要创建的各种类Person对象的原型变量。其中定义了所有类Person对象都有具备的属性和方法，并为它们提供了默认值。方法的默认值可能不会被改变，而属性的默认值一般都会被改变。</p>

<p><strong>摻元类</strong></p>

<p>有一种重用代码的方法不需要用到严格的继承。如果想把一个函数用到多个类中，可以通过扩充(augmenttation)的方法让这些类共享该函数。其具体做法是：先创建一个包含各种通用方法的类，然后再扩展其他类。这种包含通用方法的类成为摻元类(mixin class)。他们通常不会被实例化或者直接调用。其存在的目的只是向其他类提供自己的方法。具体见下面实例：</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="cm">/* Mixin class.*/</span>

<span class="kd">var</span> <span class="nx">Mixin</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{};</span>
<span class="nx">Mixin</span><span class="p">.</span><span class="nx">prototype</span><span class="p">()</span> <span class="p">{</span>
    <span class="nl">serialize</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">output</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="k">for</span> <span class="p">(</span><span class="nx">key</span> <span class="k">in</span> <span class="k">this</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">output</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">key</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">: </span><span class="dl">'</span> <span class="o">+</span> <span class="k">this</span><span class="p">[</span><span class="nx">key</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">output</span><span class="p">.</span><span class="nx">path</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">'</span><span class="s1">, </span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//使用augment函数把这个方法添加到每一个需要它的类中</span>
<span class="nx">augment</span><span class="p">(</span><span class="nx">Author</span><span class="p">,</span><span class="nx">Mixin</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">author</span><span class="o">=</span><span class="k">new</span> <span class="nx">Author</span><span class="p">(</span><span class="dl">'</span><span class="s1">Ross Harmes</span><span class="dl">'</span><span class="p">,[</span><span class="dl">'</span><span class="s1">JavaScript Design Patterns</span><span class="dl">'</span><span class="p">]);</span>
<span class="kd">var</span> <span class="nx">serializedString</span><span class="o">=</span><span class="nx">author</span><span class="p">.</span><span class="nx">serialize</span><span class="p">();</span>

<span class="cm">/*Augment function*/</span>
<span class="kd">function</span> <span class="nx">augment</span><span class="p">(</span><span class="nx">receivingClass</span><span class="p">,</span> <span class="nx">givingClass</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">arguments</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="p">{</span> <span class="c1">//Only give certain methods.</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">receivingClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">arguments</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">=</span> <span class="nx">givingClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">arguments</span><span class="p">[</span><span class="nx">i</span><span class="p">]];</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="nx">methodName</span> <span class="k">in</span> <span class="nx">givingClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">receivingClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">methodName</span><span class="p">])</span> <span class="p">{</span>
                <span class="nx">receivingClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">methodName</span><span class="p">]</span> <span class="o">=</span> <span class="nx">givingClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">methodName</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>各种继承范型各有优缺点：</p>

<ul>
  <li>在内存效率比较重要的场合原型式继承（及clone函数）是最佳选择。</li>
  <li>如果与对象打交道的都是那种只熟悉其他对象语言中的继承机制的程序员，那么最好使用类式继承（及extend函数）。</li>
  <li>以上两种方法都适合于类间差异较小的类层次体系。如果类之间差异比较大，那么摻元类的方法来扩充这些类往往是一种更合理的选择。</li>
</ul>
:ET